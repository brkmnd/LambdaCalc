<!DOCTYPE html>
<html>
<head>
<style>
.prg {
    display:none;
}
</style>
</head>
<body>
<p id="output0"></p>
<p id="output"></p>
<span class="prg" id="prg-simple1">// Simple #1
let id = (\ a . a) (\ b . b);
(\ a . \ b . \ c . a b c) (\ x . \ y . a) id
</span>
<span class="prg" id="prg-numerals">// Numerals
let id = \ v . v;
// bools
let true = \ t . \ f . t;
let false = \ t . \ f . f;
let and = \ b . \ c . b c false;
// pairs
let pair = \ f . \ s . \ b . b f s;
let fst = \ p . p true;
let snd = \ p . p false;

// num operators
let isZero = \ m . m (\ x . false) true;
let scc = \ n . \ s . \ z . s (n s z);
let plus = \ m . \ n . \ s . \ z . m s (n s z);

// church numerals
let 0 = \ s . \ z . z;
let 1 = \ s . \ z . s z;
let 2 = \ s . \ z . s (s z);
let 3 = \ s . \ z . s (s (s z));
let 4 = scc 3;
let 5 = scc 4;

// num operators decs
let zz = pair 0 0;
let ss = \ p . pair (snd p) (plus 1 (snd p));
let prd = \ m0 . fst (m0 ss zz);
let minus = \ m . \ n . n prd m;
let times = \ m . \ n . m (plus n) 0;

let test = \ l . \ m . \ n . l m n;
let equal = \ m . \ n . isZero (minus m n);


// recursion
//let fix =  \ f . (\ x . f (\ y . x x y)) (\ x . f (\ y . x x y));
//let fixFact = \ fct . \ n . test (equal n 0) 1 (times n (fct (prd n)));
//let fixSum = \ sum . \ n . test (isZero n) 0 (plus n (sum (prd n)));
let factorial = fix fixFact;
let sum = fix fixSum;

// testing
//test (isZero 0) yes no
//isZero (prd 1)
//isZero (plus 3 1)
//isZero (minus 3 1)
//isZero (times 3 3)
//test (isZero (prd (prd (prd 3)))) yes no
//test (equal (plus 2 1) 1) yes no
test (equal 5 (minus (scc 5) 1)) yes no
//scc 3
</span>
<span class="prg" id="prg-logic">// Logic
let id = \ v . v;
// operators
let true = \ t . \ f . t;
let false = \ t . \ f . f;
let and = \ b . \ c . b c false;
let or = \ b . \ c . b true c;
let not = \ b . b false true;
let imp = \ b . \ c . or (not b) c;

// conditional
let test = \ l . \ m . \ n . l m n;

// testing
//test (not true) if else
test (imp false true) if else
</span>
<span class="prg" id="prg-pairs">// Pairs
let id = \ v . v;
// operators
let true = \ t . \ f . t;
let false = \ t . \ f . f;
let and = \ b . \ c . b c false;
let or = \ b . \ c . b true c;
let not = \ b . b false true;
let imp = \ b . \ c . or (not b) c;

// conditional
let test = \ l . \ m . \ n . l m n;

// pairs
let pair = \ f . \ s . \ b . b f s;
let fst = \ p . p true;
let snd = \ p . p false;

// testing
//snd (pair v w)
test (imp (snd (pair false true)) (snd (pair true false))) if else
//test (and (snd (pair false true)) (fst (pair true false))) if else
</span>
<span class="prg" id="prg-closures">// Closures
let id = \ v . v;
let closure = (\ a . \ b . \ c . b c) ctest1 ctest2;
// testing
closure a
</span>
<span class="prg" id="prg-closure1">// Closure1 (fixed)
let id = \ v . v;
let f1 = \ a . a;
let closure = (\ a . \ b . \ c . b c) cls1 (\ a . f1);
closure a
</span>
<span class="prg" id="prg-closure2">// Closures 2
let id = \ v . v;
let f1 = \ a . a;
let closure = (\ a . \ b . \ c . b c a) cls1 (\ a . (\ b . b) f1);
closure a
</span>
<!-- Failing Programs -->
<script src="stack.js"></script>
<script src="lcalc.js"></script>
<script>
    //var prgName = "simple1";
    var prgName = "numerals";
    var printfn = function(){
        var elm = document.getElementById("output");
        elm.style.fontFamily = "monospace";
        elm.style.fontSize = "12pt";
        elm.style.whiteSpace = "pre";
        return function(ptype,line){
            switch(ptype){
                case "error":
                    elm.innerHTML += "<font color='red'>"+line+"</font>";
                    break;
                case "env":
                    elm.innerHTML += "&rho;"+line;
                    break;
                case "res":
                    elm.innerHTML += line;
                    break;
                case "tnode":
                    elm.innerHTML += line;
                    break;
                default:
                    elm.innerHTML += line;
                    break;
                }
            elm.innerHTML += "\n";
            };
        }();
    var prg = document.getElementById("prg-"+prgName);
    var llang = new LambdaLang(printfn);
    var printCode = function(){
        var texta = document.getElementById("output0");
        texta.style.backgroundColor = "black";
        texta.style.color = "white";
        texta.style.fontFamily = "monospace";
        texta.style.fontSize = "12pt";
        texta.style.whiteSpace = "pre";
        texta.innerHTML = prg.innerHTML;
        }();
    // Print the parsing tree
    printfn("","----Abstact Syntax Tree");
    llang.printTree(prg.innerHTML);
    printfn("","");
    printfn("","----Evaluation Result");
    // Print result
    try {
        llang.evalPrg(prg.innerHTML)
    } catch(err) {
        printfn("error","runtime error: "+err.message);
    }
    printfn("","");
    printfn("","recs");
    printfn("","eval depth [defs]:"+llang.recCounts.defs.toString());
    printfn("","eval depth [term]:"+llang.recCounts.term.toString());
    printfn("","eval depth [apps]:"+llang.recCounts.apps.toString());
    printfn("","eval depth [vars]:"+llang.recCounts.vars.toString());
    printfn("","eval depth [abstrs]:"+llang.recCounts.abstrs.toString());
</script>
</body>
</html>
